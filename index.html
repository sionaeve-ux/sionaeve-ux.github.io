<!-- Save this file as fish.html and open in your browser -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Swimming Fish</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background: linear-gradient(#87CEEB, #0b3d66); }
    #canvas {
      display:block;
      width:100%;
      height:100%;
    }
    .credit {
      position:fixed;
      left:8px;
      bottom:8px;
      color: rgba(255,255,255,0.9);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      font-size:13px;
      background: rgba(0,0,0,0.2);
      padding:6px 8px;
      border-radius:6px;
      backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="credit">Click or tap to make the fish dart toward that point.</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: true });

  // Resize canvas to match window device pixel ratio for sharpness
  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawing operations for DPR
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // Utility
  function lerp(a,b,t){ return a + (b - a) * t; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function rand(min,max){ return Math.random() * (max - min) + min; }
  function angleDiff(a, b){ // shortest signed difference
    let d = b - a;
    while (d > Math.PI) d -= Math.PI * 2;
    while (d < -Math.PI) d += Math.PI * 2;
    return d;
  }

  // Fish object
  const fish = {
    x: canvas.width / 2 / (window.devicePixelRatio || 1),
    y: canvas.height / 2 / (window.devicePixelRatio || 1),
    vx: 0,
    vy: 0,
    angle: 0,
    targetAngle: 0,
    speed: 0,
    targetSpeed: 0.8,
    tailPhase: 0,
    size: 60, // base size (pixels)
    colorBody: '#ff9f43',
    colorAccent: '#ffd27a',
    eyeColor: '#222',
    time: 0,
    wanderTimer: 0,
    targetX: null,
    targetY: null
  };

  // Bubbles for visual interest
  const bubbles = [];
  function spawnBubble(x,y,radius,vy){
    bubbles.push({ x, y, r: radius, vy, alpha: 1 });
  }

  // Click / touch to direct the fish
  function setTarget(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const px = (clientX - rect.left);
    const py = (clientY - rect.top);
    fish.targetX = px;
    fish.targetY = py;
    // give fish a burst of speed
    fish.targetSpeed = rand(2.2, 3.4);
  }
  canvas.addEventListener('click', (e)=> setTarget(e.clientX, e.clientY));
  canvas.addEventListener('touchstart', (e)=> {
    if (e.touches && e.touches[0]) {
      setTarget(e.touches[0].clientX, e.touches[0].clientY);
    }
  }, {passive:true});

  // Main animation loop
  let last = performance.now();
  function tick(now) {
    const dt = Math.min(0.05, (now - last) / 1000); // seconds, cap at 50ms
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(tick);
  }

  function update(dt) {
    fish.time += dt;
    fish.tailPhase += dt * 10; // tail wag speed

    // Wandering target if none set or after a while
    fish.wanderTimer -= dt;
    if (fish.wanderTimer <= 0 && fish.targetX === null) {
      fish.wanderTimer = rand(1.2, 3.0);
      fish.targetX = rand(80, window.innerWidth - 80);
      fish.targetY = rand(80, window.innerHeight - 80);
      fish.targetSpeed = rand(0.8, 1.6);
    }

    // If reached click target, clear it after closish distance
    if (fish.targetX !== null) {
      const dx = fish.targetX - fish.x;
      const dy = fish.targetY - fish.y;
      const dist = Math.hypot(dx,dy);
      if (dist < 14) {
        fish.targetX = null;
        fish.targetY = null;
        fish.targetSpeed = rand(0.7, 1.5);
      }
    }

    // Compute desired angle toward target or continue a small wandering
    let desiredAngle = fish.angle;
    if (fish.targetX !== null) {
      desiredAngle = Math.atan2(fish.targetY - fish.y, fish.targetX - fish.x);
    } else {
      // slight perpetual circular wandering
      desiredAngle += Math.sin(fish.time * 0.5) * 0.02;
    }
    // Smoothly turn towards desiredAngle
    const dA = angleDiff(fish.angle, desiredAngle);
    const turnSpeed = 3.5; // radians/sec max turning potency
    fish.angle += clamp(dA, -turnSpeed * dt, turnSpeed * dt);

    // Speed smoothing
    fish.speed = lerp(fish.speed, fish.targetSpeed, clamp(dt * 2.5, 0, 1));

    // Velocity from angle
    fish.vx = Math.cos(fish.angle) * fish.speed * 60 * (fish.size / 60) * dt;
    fish.vy = Math.sin(fish.angle) * fish.speed * 60 * (fish.size / 60) * dt;

    fish.x += fish.vx;
    fish.y += fish.vy;

    // Gentle bobbing up/down relative to travel
    fish.y += Math.sin(fish.time * 2 + fish.x * 0.01) * 0.4;

    // Keep fish in bounds with wrap-around (teleport to other side smoothly)
    const w = window.innerWidth, h = window.innerHeight;
    if (fish.x < -80) fish.x = w + 80;
    if (fish.x > w + 80) fish.x = -80;
    if (fish.y < -80) fish.y = h + 80;
    if (fish.y > h + 80) fish.y = -80;

    // Occasionally spawn bubbles behind fish
    if (Math.random() < 0.04) {
      const bx = fish.x - Math.cos(fish.angle) * fish.size * 0.6 + rand(-6,6);
      const by = fish.y - Math.sin(fish.angle) * fish.size * 0.6 + rand(-6,6);
      spawnBubble(bx, by, rand(3,10), rand(-8, -30));
    }

    // Update bubbles
    for (let i = bubbles.length - 1; i >= 0; i--) {
      const b = bubbles[i];
      b.y += b.vy * dt;
      b.alpha -= dt * 0.25;
      b.x += Math.sin(fish.time + i) * dt * 4;
      if (b.alpha <= 0 || b.y < -20) bubbles.splice(i,1);
    }
  }

  // Draw the fish
  function drawFish(ctx, f) {
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.rotate(f.angle);

    const s = f.size / 60; // scale factor
    // body
    ctx.beginPath();
    ctx.ellipse(0, 0, 46 * s, 28 * s, 0, 0, Math.PI * 2);
    ctx.fillStyle = f.colorBody;
    ctx.fill();
    // accent belly
    ctx.beginPath();
    ctx.ellipse(-6 * s, 6 * s, 26 * s, 16 * s, 0, 0, Math.PI * 2);
    ctx.fillStyle = f.colorAccent;
    ctx.globalAlpha = 0.95;
    ctx.fill();
    ctx.globalAlpha = 1;

    // tail (wags using tailPhase)
    const tailWag = Math.sin(f.tailPhase * 2.2) * 0.8; // [-0.8,0.8]
    ctx.save();
      ctx.translate(-46 * s, 0);
      ctx.rotate(tailWag * 0.5);
      // triangular tail shape
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-26 * s, 14 * s);
      ctx.lineTo(-26 * s, -14 * s);
      ctx.closePath();
      ctx.fillStyle = shadeColor(f.colorBody, -6);
      ctx.fill();

      // tail inner accent
      ctx.beginPath();
      ctx.moveTo(-6 * s, 0);
      ctx.lineTo(-20 * s, 8 * s);
      ctx.lineTo(-20 * s, -8 * s);
      ctx.closePath();
      ctx.fillStyle = f.colorAccent;
      ctx.globalAlpha = 0.9;
      ctx.fill();
      ctx.globalAlpha = 1;
    ctx.restore();

    // dorsal fin on top
    ctx.save();
      ctx.translate(-4 * s, -18 * s);
      ctx.rotate(Math.sin(f.tailPhase * 1.6) * 0.08);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(10 * s, -14 * s, 28 * s, -6 * s);
      ctx.lineTo(10 * s, 6 * s);
      ctx.closePath();
      ctx.fillStyle = shadeColor(f.colorBody, 6);
      ctx.fill();
    ctx.restore();

    // pectoral fin (side) - flaps a bit
    ctx.save();
      ctx.translate(6 * s, 8 * s);
      ctx.rotate(Math.sin(f.tailPhase * 2.4) * 0.8);
      ctx.beginPath();
      ctx.ellipse(0, 0, 8 * s, 14 * s, Math.PI * 0.2, 0, Math.PI * 2);
      ctx.fillStyle = shadeColor(f.colorAccent, -8);
      ctx.fill();
    ctx.restore();

    // eye
    ctx.save();
      ctx.translate(18 * s, -4 * s);
      // white
      ctx.beginPath();
      ctx.arc(0, 0, 6 * s, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
      // pupil
      ctx.beginPath();
      ctx.arc(1.3 * s, 0.6 * s, 3.2 * s, 0, Math.PI * 2);
      ctx.fillStyle = f.eyeColor;
      ctx.fill();
      // small shine
      ctx.beginPath();
      ctx.arc(0.2 * s, -1 * s, 1.2 * s, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.fill();
    ctx.restore();

    ctx.restore();
  }

  // Helper to darken/lighten hex color slightly
  function shadeColor(hex, percent) {
    // hex like "#rrggbb"
    const c = hex.replace('#','');
    const num = parseInt(c,16);
    let r = (num >> 16) + percent;
    let g = ((num >> 8) & 0x00FF) + percent;
    let b = (num & 0x0000FF) + percent;
    r = clamp(Math.round(r), 0, 255);
    g = clamp(Math.round(g), 0, 255);
    b = clamp(Math.round(b), 0, 255);
    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }

  function draw() {
    // clear canvas with translucent blue to create slight motion blur effect
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // draw background subtle gradient (drawn to device pixels via CSS; here we overlay some sea fog)
    const grd = ctx.createLinearGradient(0,0,0,window.innerHeight);
    grd.addColorStop(0, 'rgba(255,255,255,0.02)');
    grd.addColorStop(1, 'rgba(0,0,0,0.06)');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,window.innerWidth, window.innerHeight);

    // draw bubbles
    for (const b of bubbles) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,255,255,${0.12 * b.alpha})`;
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = `rgba(255,255,255,${0.28 * b.alpha})`;
      ctx.stroke();
    }

    // draw fish
    drawFish(ctx, fish);
  }

  // Start animation
  requestAnimationFrame(tick);

  // Gentle initial drifting target
  fish.targetSpeed = 1.1;
  fish.wanderTimer = 0.5;

})();
</script>
</body>
</html>
